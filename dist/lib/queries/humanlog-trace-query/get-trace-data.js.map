{"version":3,"sources":["../../../../src/queries/humanlog-trace-query/get-trace-data.ts"],"sourcesContent":["import { DurationString, TraceData, TraceSearchResult } from \"@perses-dev/core\";\nimport { TraceQueryPlugin, replaceVariables } from \"@perses-dev/plugin-system\";\nimport {\n  HumanlogTraceQuerySpec,\n  DatasourceTraceQueryResponse,\n} from \"./humanlog-trace-query-types\";\nimport { DEFAULT_DATASOURCE } from \"../constants\";\nimport { HumanlogDatasourceClient } from \"../../datasources\";\nimport {\n  Event,\n  ResourceSpan,\n  Span,\n  Status,\n  TracesData,\n} from \"@perses-dev/core/dist/model/otlp/trace/v1/trace\";\nimport { Spans } from \"api/js/types/v1/data_pb\";\nimport { Resource as HLResource } from \"api/js/types/v1/otel_resource_pb\";\nimport { Scope as HLScope } from \"api/js/types/v1/otel_scope_pb\";\nimport {\n  Span as HLSpan,\n  Span_Event as HLEvent,\n  Span_Status as HLStatus,\n} from \"api/js/types/v1/otel_tracing_pb\";\nimport { Resource } from \"@perses-dev/core/dist/model/otlp/resource/v1/resource\";\nimport { KV, Val } from \"api/js/types/v1/types_pb\";\nimport {\n  AnyValue,\n  InstrumentationScope,\n  KeyValue,\n} from \"@perses-dev/core/dist/model/otlp/common/v1/common\";\nimport { Duration } from \"@bufbuild/protobuf/wkt\";\nimport { protobufToDate } from \"../../utils/time\";\nimport { spanIdToString, traceIdToString } from \"../../utils/id-factories\";\n\nfunction buildTrace(\n  response?: DatasourceTraceQueryResponse,\n): TracesData | undefined {\n  if (!response) {\n    return undefined;\n  }\n\n  let spans: Spans;\n  switch (response.data.data?.shape.case) {\n    case \"spans\":\n      spans = response.data.data?.shape.value;\n      break;\n    default:\n      throw new Error(\n        \"query result is not tracing data: \" + response.data.data?.shape.case,\n      );\n  }\n\n  const hl2otlpValue = (v: Val): AnyValue => {\n    switch (v.kind.case) {\n      case \"str\":\n        return { stringValue: v.kind.value };\n      case \"f64\":\n        return { intValue: v.kind.value.toString() };\n      case \"i64\":\n        return { intValue: v.kind.value.toString() };\n      case \"bool\":\n        return { boolValue: v.kind.value };\n      case \"arr\":\n        return { arrayValue: { values: v.kind.value.items.map(hl2otlpValue) } };\n      default:\n        throw new Error(\"unsupported key-value type: \" + v.kind.case);\n    }\n  };\n\n  const hl2otlpKeyValue = (kv: KV): KeyValue => {\n    return { key: kv.key, value: hl2otlpValue(kv.value!) };\n  };\n\n  const hl2otlpResource = (res: HLResource): Resource => {\n    return { attributes: res.attributes.map(hl2otlpKeyValue) };\n  };\n  const hl2otlpScope = (res: HLScope): InstrumentationScope => {\n    return { name: res.name };\n  };\n  const hl2otlpEvent = (res: HLEvent): Event => {\n    return {\n      timeUnixNano: timestampToUnixNanoString(\n        protobufToDate(res.timestamp!) || new Date(),\n      ),\n      name: res.name || \"\",\n      attributes: res.kvs.map(hl2otlpKeyValue),\n    };\n  };\n  const hl2otlpStatus = (res: HLStatus | undefined): Status => {\n    if (!res) {\n      return {\n        code: \"STATUS_CODE_UNSET\" as const,\n        message: \"\",\n      };\n    }\n\n    // Convert HumanLog status code to OTLP status code\n    let statusCode:\n      | \"STATUS_CODE_UNSET\"\n      | \"STATUS_CODE_OK\"\n      | \"STATUS_CODE_ERROR\";\n    switch (res.code) {\n      case 0: // UNSET\n        statusCode = \"STATUS_CODE_UNSET\";\n        break;\n      case 1: // OK\n        statusCode = \"STATUS_CODE_OK\";\n        break;\n      case 2: // ERROR\n        statusCode = \"STATUS_CODE_ERROR\";\n        break;\n      default:\n        statusCode = \"STATUS_CODE_UNSET\";\n    }\n\n    return {\n      code: statusCode,\n      message: res.message || \"\",\n    };\n  };\n  const timestampToUnixNanoString = (ts: Date): string => {\n    return (ts.getTime() * 1000000).toString();\n  };\n\n  const addDurationToDate = (ts: Date, dur: Duration): Date => {\n    // Extract seconds and nanoseconds from Duration\n    const seconds = Number(dur.seconds || 0);\n    const nanos = dur.nanos || 0;\n\n    // Convert duration to milliseconds and add to timestamp\n    const durationMs = seconds * 1000 + nanos / 1000000;\n\n    return new Date(ts.getTime() + durationMs);\n  };\n\n  const hl2otlpSpan = (res: HLSpan): Span => {\n    res.time?.nanos;\n    const start = protobufToDate(res.time!);\n    const end = addDurationToDate(start, res.duration!);\n    const traceId = traceIdToString(res.traceId);\n    const spanId = spanIdToString(res.spanId);\n    const parentSpanId = spanIdToString(res.parentSpanId);\n    return {\n      traceId,\n      spanId,\n      parentSpanId,\n      name: res.name,\n      kind: res.kind.toString(),\n      startTimeUnixNano: timestampToUnixNanoString(start),\n      endTimeUnixNano: timestampToUnixNanoString(end),\n      attributes: res.attributes.map(hl2otlpKeyValue),\n      events: res.events?.map(hl2otlpEvent) || [],\n      status: hl2otlpStatus(res.status),\n    };\n  };\n\n  let resSpans = new Map<bigint, ResourceSpan>();\n\n  spans.spans.forEach((sp) => {\n    if (!sp.resource) {\n      throw new Error(\"span doesn't have a resource\");\n    }\n    const resID = sp.resource?.resourceHash64;\n    let resSpan = resSpans.get(resID);\n    if (!resSpan) {\n      const res = hl2otlpResource(sp.resource!);\n      resSpan = {\n        resource: res,\n        scopeSpans: [],\n      };\n    }\n    const scope = resSpan.scopeSpans.find((sc) => {\n      sc.scope?.name == sp.scope?.name;\n    });\n    if (!scope) {\n      resSpan.scopeSpans = [\n        {\n          scope: hl2otlpScope(sp.scope!),\n          spans: [hl2otlpSpan(sp)],\n        },\n      ];\n    } else {\n      scope.spans.push(hl2otlpSpan(sp));\n    }\n    // update the value\n    resSpans.set(resID, resSpan);\n  });\n\n  const out: TracesData = {\n    resourceSpans: Array.from(resSpans.values()),\n  };\n  return out;\n}\n\nfunction buildSearchResult(\n  response?: DatasourceTraceQueryResponse,\n): TraceSearchResult[] {\n  if (!response) {\n    return [];\n  }\n\n  let spans: Spans;\n  switch (response.data.data?.shape.case) {\n    case \"spans\":\n      spans = response.data.data?.shape.value;\n      break;\n    default:\n      return [];\n  }\n\n  // Group spans by traceId and find the earliest start time and service name for each trace\n  const traceMap = new Map<\n    string,\n    {\n      traceId: string;\n      spanCount: number;\n      serviceName: string;\n      startTime: Date;\n      duration: number;\n    }\n  >();\n\n  spans.spans.forEach((span) => {\n    const traceId = traceIdToString(span.traceId);\n    const startTime = protobufToDate(span.time!) || new Date();\n    const duration = span.duration\n      ? Number(span.duration.seconds || 0) * 1000 +\n        (span.duration.nanos || 0) / 1000000\n      : 0;\n\n    const existing = traceMap.get(traceId);\n    if (!existing || startTime < existing.startTime) {\n      traceMap.set(traceId, {\n        traceId,\n        spanCount: existing ? existing.spanCount + 1 : 1,\n        serviceName: span.serviceName || \"unknown\",\n        startTime,\n        duration: existing ? Math.max(existing.duration, duration) : duration,\n      });\n    } else {\n      existing.spanCount += 1;\n      existing.duration = Math.max(existing.duration, duration);\n    }\n  });\n\n  return Array.from(traceMap.values()).map((trace) => ({\n    traceId: trace.traceId,\n    rootServiceName: trace.serviceName,\n    rootTraceName: trace.serviceName, // Use service name as trace name if no specific root span name\n    startTimeUnixMs: trace.startTime.getTime(),\n    durationMs: trace.duration,\n    spanCount: trace.spanCount,\n    serviceStats: {\n      [trace.serviceName]: {\n        spanCount: trace.spanCount,\n        errorCount: 0, // TODO: Count error spans if needed\n      },\n    },\n  }));\n}\n\nexport const getTraceData: TraceQueryPlugin<HumanlogTraceQuerySpec>[\"getTraceData\"] =\n  async (spec, context) => {\n    // return empty data if the query is empty\n    if (spec.query === undefined || spec.query === null || spec.query === \"\") {\n      return {};\n    }\n\n    const query = replaceVariables(spec.query, context.variableState);\n\n    const client = (await context.datasourceStore.getDatasourceClient(\n      // A default datasource will be selected by matching the kind of datasource if not provided\n      spec.datasource ?? DEFAULT_DATASOURCE,\n    )) as HumanlogDatasourceClient;\n\n    const response = await client.query({\n      start: \"\",\n      end: \"\",\n      query,\n    });\n\n    const chartData: TraceData = {\n      trace: buildTrace(response),\n      searchResult: buildSearchResult(response),\n      metadata: {\n        executedQueryString: query,\n      },\n    };\n\n    return chartData;\n  };\n"],"names":["replaceVariables","DEFAULT_DATASOURCE","protobufToDate","spanIdToString","traceIdToString","buildTrace","response","undefined","spans","data","shape","case","value","Error","hl2otlpValue","v","kind","stringValue","intValue","toString","boolValue","arrayValue","values","items","map","hl2otlpKeyValue","kv","key","hl2otlpResource","res","attributes","hl2otlpScope","name","hl2otlpEvent","timeUnixNano","timestampToUnixNanoString","timestamp","Date","kvs","hl2otlpStatus","code","message","statusCode","ts","getTime","addDurationToDate","dur","seconds","Number","nanos","durationMs","hl2otlpSpan","time","start","end","duration","traceId","spanId","parentSpanId","startTimeUnixNano","endTimeUnixNano","events","status","resSpans","Map","forEach","sp","resource","resID","resourceHash64","resSpan","get","scopeSpans","scope","find","sc","push","set","out","resourceSpans","Array","from","buildSearchResult","traceMap","span","startTime","existing","spanCount","serviceName","Math","max","trace","rootServiceName","rootTraceName","startTimeUnixMs","serviceStats","errorCount","getTraceData","spec","context","query","variableState","client","datasourceStore","getDatasourceClient","datasource","chartData","searchResult","metadata","executedQueryString"],"mappings":"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"}