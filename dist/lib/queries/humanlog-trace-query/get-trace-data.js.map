{"version":3,"sources":["../../../../src/queries/humanlog-trace-query/get-trace-data.ts"],"sourcesContent":["import { DurationString, TraceData, TraceSearchResult } from \"@perses-dev/core\";\nimport { TraceQueryPlugin, replaceVariables } from \"@perses-dev/plugin-system\";\nimport {\n  HumanlogTraceQuerySpec,\n  DatasourceTraceQueryResponse,\n} from \"./humanlog-trace-query-types\";\nimport { DEFAULT_DATASOURCE } from \"../constants\";\nimport { Duration, Timestamp } from \"@bufbuild/protobuf\";\nimport { HumanlogDatasourceClient } from \"../../datasources\";\nimport {\n  Event,\n  ResourceSpan,\n  Span,\n  Status,\n  TracesData,\n} from \"@perses-dev/core/dist/model/otlp/trace/v1/trace\";\nimport { Spans } from \"api/js/types/v1/data_pb\";\nimport { Resource as HLResource } from \"api/js/types/v1/otel_resource_pb\";\nimport { Scope as HLScope } from \"api/js/types/v1/otel_scope_pb\";\nimport {\n  Span as HLSpan,\n  Span_Event as HLEvent,\n  Span_Status as HLStatus,\n} from \"api/js/types/v1/otel_tracing_pb\";\nimport { Resource } from \"@perses-dev/core/dist/model/otlp/resource/v1/resource\";\nimport { KV, Val } from \"api/js/types/v1/types_pb\";\nimport {\n  AnyValue,\n  InstrumentationScope,\n  KeyValue,\n} from \"@perses-dev/core/dist/model/otlp/common/v1/common\";\n\nfunction buildTrace(\n  response?: DatasourceTraceQueryResponse,\n): TracesData | undefined {\n  if (!response) {\n    return undefined;\n  }\n\n  let spans: Spans;\n  switch (response.data.data?.shape.case) {\n    case \"spans\":\n      spans = response.data.data?.shape.value;\n      break;\n    default:\n      throw new Error(\n        \"query result is not tracing data: \" + response.data.data?.shape.case,\n      );\n  }\n\n  const hl2otlpValue = (v: Val): AnyValue => {\n    switch (v.kind.case) {\n      case \"str\":\n        return { stringValue: v.kind.value };\n      case \"f64\":\n        return { intValue: v.kind.value.toString() };\n      case \"i64\":\n        return { intValue: v.kind.value.toString() };\n      case \"bool\":\n        return { boolValue: v.kind.value };\n      case \"arr\":\n        return { arrayValue: { values: v.kind.value.items.map(hl2otlpValue) } };\n      default:\n        throw new Error(\"unsupported key-value type: \" + v.kind.case);\n    }\n  };\n\n  const hl2otlpKeyValue = (kv: KV): KeyValue => {\n    return { key: kv.key, value: hl2otlpValue(kv.value!) };\n  };\n\n  const hl2otlpResource = (res: HLResource): Resource => {\n    return { attributes: res.attributes.map(hl2otlpKeyValue) };\n  };\n  const hl2otlpScope = (res: HLScope): InstrumentationScope => {\n    return { name: res.name };\n  };\n  const hl2otlpEvent = (res: HLEvent): Event => {\n    throw new Error(\"todo\");\n  };\n  const hl2otlpStatus = (res: HLStatus | undefined): Status => {\n    throw new Error(\"todo\");\n  };\n  const timestampToUnixNanoString = (ts: Date): string => {\n    throw new Error(\"todo\");\n  };\n\n  const addDurationToDate = (ts: Date, dur: Duration): Date => {\n    throw new Error(\"todo\");\n  };\n\n  const hl2otlpSpan = (res: HLSpan): Span => {\n    const start = res.time!.toDate();\n    const end = addDurationToDate(start, res.duration!);\n    return {\n      traceId: res.traceId,\n      spanId: res.spanId,\n      parentSpanId: res.parentSpanId,\n      name: res.name,\n      kind: res.kind.toString(),\n      startTimeUnixNano: timestampToUnixNanoString(start),\n      endTimeUnixNano: timestampToUnixNanoString(end),\n      attributes: res.attributes.map(hl2otlpKeyValue),\n      events: res.events.map(hl2otlpEvent),\n      status: hl2otlpStatus(res.status),\n    };\n  };\n\n  let resSpans = new Map<bigint, ResourceSpan>();\n\n  spans.spans.forEach((sp) => {\n    if (!sp.resource) {\n      throw new Error(\"span doesn't have a resource\");\n    }\n    const resID = sp.resource?.resourceHash64;\n    let resSpan = resSpans.get(resID);\n    if (!resSpan) {\n      const res = hl2otlpResource(sp.resource!);\n      resSpan = {\n        resource: res,\n        scopeSpans: [],\n      };\n    }\n    const scope = resSpan.scopeSpans.find((sc) => {\n      sc.scope?.name == sp.scope?.name;\n    });\n    if (!scope) {\n      resSpan.scopeSpans = [\n        {\n          scope: hl2otlpScope(sp.scope!),\n          spans: [hl2otlpSpan(sp)],\n        },\n      ];\n    } else {\n      scope.spans.push(hl2otlpSpan(sp));\n    }\n    // update the value\n    resSpans.set(resID, resSpan);\n  });\n\n  const out: TracesData = {\n    resourceSpans: Array.from(resSpans.values()),\n  };\n  return out;\n}\n\nfunction buildSearchResult(\n  response?: DatasourceTraceQueryResponse,\n): TraceSearchResult[] {\n  if (!response) {\n    return [];\n  }\n\n  return [];\n}\n\nexport const getTraceData: TraceQueryPlugin<HumanlogTraceQuerySpec>[\"getTraceData\"] =\n  async (spec, context) => {\n    // return empty data if the query is empty\n    if (spec.query === undefined || spec.query === null || spec.query === \"\") {\n      return {};\n    }\n\n    const query = replaceVariables(spec.query, context.variableState);\n\n    const client = (await context.datasourceStore.getDatasourceClient(\n      // A default datasource will be selected by matching the kind of datasource if not provided\n      spec.datasource ?? DEFAULT_DATASOURCE,\n    )) as HumanlogDatasourceClient;\n\n    const response = await client.query({\n      start: \"\",\n      end: \"\",\n      query,\n    });\n\n    const chartData: TraceData = {\n      trace: buildTrace(response),\n      searchResult: buildSearchResult(response),\n      metadata: {\n        executedQueryString: query,\n      },\n    };\n\n    return chartData;\n  };\n"],"names":["replaceVariables","DEFAULT_DATASOURCE","buildTrace","response","undefined","spans","data","shape","case","value","Error","hl2otlpValue","v","kind","stringValue","intValue","toString","boolValue","arrayValue","values","items","map","hl2otlpKeyValue","kv","key","hl2otlpResource","res","attributes","hl2otlpScope","name","hl2otlpEvent","hl2otlpStatus","timestampToUnixNanoString","ts","addDurationToDate","dur","hl2otlpSpan","start","time","toDate","end","duration","traceId","spanId","parentSpanId","startTimeUnixNano","endTimeUnixNano","events","status","resSpans","Map","forEach","sp","resource","resID","resourceHash64","resSpan","get","scopeSpans","scope","find","sc","push","set","out","resourceSpans","Array","from","buildSearchResult","getTraceData","spec","context","query","variableState","client","datasourceStore","getDatasourceClient","datasource","chartData","trace","searchResult","metadata","executedQueryString"],"mappings":"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"}