{"version":3,"sources":["../../../../src/queries/humanlog-time-series-query/get-time-series-data.ts"],"sourcesContent":["import { TimeSeriesData, TimeSeries } from \"@perses-dev/core\";\nimport {\n  TimeSeriesQueryPlugin,\n  replaceVariables,\n} from \"@perses-dev/plugin-system\";\nimport {\n  HumanlogTimeSeriesQuerySpec,\n  DatasourceTimeSeriesQueryResponse,\n} from \"./humanlog-time-series-query-types\";\nimport { DEFAULT_DATASOURCE } from \"../constants\";\nimport { HumanlogDatasourceClient } from \"../../datasources\";\nimport { Table, TableType_Column } from \"api/js/types/v1/types_pb\";\nimport { ScalarType } from \"api/js/types/v1/types_pb\";\n\nfunction buildTimeSeries(\n  response?: DatasourceTimeSeriesQueryResponse,\n): TimeSeries[] {\n  console.log(\"buildTimeSeries called with response:\", response);\n\n  if (\n    !response?.data?.data?.shape.case ||\n    response.data.data.shape.case !== \"freeForm\"\n  ) {\n    return [];\n  }\n\n  const table = response.data.data.shape.value as Table;\n  const { type, rows } = table;\n\n  if (!type?.columns || rows.length === 0) {\n    return [];\n  }\n\n  // Find time and value columns\n  const timeColumnIndex = type.columns.findIndex(\n    (col: TableType_Column) =>\n      col.type?.type?.case === \"scalar\" &&\n      col.type.type.value === ScalarType.ts,\n  );\n\n  // Look for numeric value columns first, then duration columns\n  let valueColumnIndex = type.columns.findIndex(\n    (col: TableType_Column) =>\n      col.type?.type?.case === \"scalar\" &&\n      (col.type.type.value === ScalarType.f64 ||\n        col.type.type.value === ScalarType.i64),\n  );\n\n  // If no numeric columns found, look for duration column\n  if (valueColumnIndex === -1) {\n    valueColumnIndex = type.columns.findIndex(\n      (col: TableType_Column) =>\n        col.type?.type?.case === \"scalar\" &&\n        col.type.type.value === ScalarType.dur,\n    );\n  }\n\n  if (timeColumnIndex === -1 || valueColumnIndex === -1) {\n    return [];\n  }\n\n  // Convert rows to time series data\n  const values: [number, number | null][] = [];\n\n  for (const row of rows) {\n    const timeVal = row.items[timeColumnIndex];\n    const valueVal = row.items[valueColumnIndex];\n\n    if (!timeVal || !valueVal) continue;\n\n    // Extract timestamp\n    let timestamp: number;\n    if (timeVal.kind.case === \"ts\") {\n      timestamp = timeVal.kind.value.toDate().getTime();\n    } else {\n      continue; // Skip if not timestamp\n    }\n\n    // Extract value\n    let value: number | null;\n    if (valueVal.kind.case === \"f64\") {\n      value = valueVal.kind.value;\n    } else if (valueVal.kind.case === \"i64\") {\n      value = Number(valueVal.kind.value);\n    } else if (valueVal.kind.case === \"dur\") {\n      // Convert duration to milliseconds\n      const duration = valueVal.kind.value;\n      const seconds = Number(duration.seconds || 0);\n      const nanos = duration.nanos || 0;\n      value = seconds * 1000 + nanos / 1000000; // Convert to milliseconds\n    } else {\n      value = null;\n    }\n\n    values.push([timestamp, value]);\n  }\n\n  // Sort by timestamp\n  values.sort((a, b) => a[0] - b[0]);\n\n  const result = [\n    {\n      name: \"humanlog-time-series\",\n      values,\n    },\n  ];\n\n  console.log(\"Returning result:\", result);\n  return result;\n}\n\nexport const getTimeSeriesData: TimeSeriesQueryPlugin<HumanlogTimeSeriesQuerySpec>[\"getTimeSeriesData\"] =\n  async (spec, context) => {\n    // return empty data if the query is empty\n    if (spec.query === undefined || spec.query === null || spec.query === \"\") {\n      return { series: [] };\n    }\n\n    const query = replaceVariables(spec.query, context.variableState);\n\n    const client = (await context.datasourceStore.getDatasourceClient(\n      // A default datasource will be selected by matching the kind of datasource if not provided\n      spec.datasource ?? DEFAULT_DATASOURCE,\n    )) as HumanlogDatasourceClient;\n\n    const { start, end } = context.timeRange;\n\n    const response = await client.query({\n      start: start.getTime().toString(),\n      end: end.getTime().toString(),\n      query,\n    });\n\n    const chartData: TimeSeriesData = {\n      series: buildTimeSeries(response),\n      timeRange: { start, end },\n      stepMs: 30 * 1000,\n      metadata: {\n        executedQueryString: query,\n      },\n    };\n\n    return chartData;\n  };\n"],"names":["replaceVariables","DEFAULT_DATASOURCE","ScalarType","buildTimeSeries","response","console","log","data","shape","case","table","value","type","rows","columns","length","timeColumnIndex","findIndex","col","ts","valueColumnIndex","f64","i64","dur","values","row","timeVal","items","valueVal","timestamp","kind","toDate","getTime","Number","duration","seconds","nanos","push","sort","a","b","result","name","getTimeSeriesData","spec","context","query","undefined","series","variableState","client","datasourceStore","getDatasourceClient","datasource","start","end","timeRange","toString","chartData","stepMs","metadata","executedQueryString"],"mappings":"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"}